//
// Created by jeune on 07/02/2023.
//
#pragma once
// y² = x^3 + ax + b

//Symétrie A(x,y) => B(x,-y)

#include <cmath>
#include <iostream>
#include "Point.h"
#include "Modulus.h"

/**
 *
 * TODO:
 *  2/ Point doubling: Given a point P on the curve, this method calculates
 *  the point 2P such that 2P is another point on the curve.
 *  This is done by finding the tangent to the curve at P and finding
 *  the second point where this tangent intersects the curve.
 *
 * TODO:
 *  3/Scalar multiplication: Given a point P on the curve and a scalar value k,
 *  this method calculates the point kP such that kP is another point on the curve.
 *  This is done by repeatedly adding P to itself k times,
 *  or by using faster algorithms such as double-and-add or Montgomery ladder.
 *
 * TODO:
 *  4/Point compression: Given a point P on the curve, this method compresses the point
 *  into a fixed-length representation for efficient storage and transmission.
 *  This is typically done by encoding the x-coordinate of the point
 *  and a flag indicating whether the y-coordinate is even or odd.
 *
 * TODO:
 *  5/Point decompression: Given a compressed point representation,
 *  this method decompresses the point back into its original form on the curve.
 *
 * TODO:
 *  6/Key generation: This method generates a public/private key pair for use in EllipticCurveEnc.
 *  The private key is a scalar value and the public key is a point on the curve.
 *  The public key is generated by multiplying the private key by the generator point of the curve.
 *
 * TODO:
 *  7/Signature generation: Given a message and a private key,
 *  this method generates a digital signature for the message.
 *  The signature is typically a pair of values that can be verified using the public key and the message.
 *
 * TODO:
 *  8/Signature verification: Given a signature, a message, and a public key,
 *  this method verifies whether the signature is a valid signature for the message.
 *  If the signature is valid, the method returns true, otherwise it returns false.
 */
//template <unsigned long long A, unsigned long long B>
template<typename T>
class EllipticCurve {
    //y² === x^3 + Ax + B mod P
    // Field = P ; Fp = {0,1,...,p-1}
    // Need special point aka imaginary point == point soit sur +infini ou -infini
        T A;
        T B;
        T P;

        public:
    EllipticCurve(T modulo,
                  T a,
                  T b)
                  : A(a), B(b), P(modulo) {};

    //Point doubling ? <-- Use la tan d'un point puis symétrique par rapport a x pour récup

    //Chord Method || Point doubling si P == Q

    Point<T> addition(Point<T> &p, Point<T> &q) const {
        T m = p != q ?
                fmod((q.y - p.y),P) * Mod::qMod( T(1), (q.x - p.x), P) :
                fmod(((3* p.x * p.x) + A) , P) * Mod::qMod(T(1), (2*p.y), P) ;
        T resX = fmod(m*m - p.x - q.x , P);
        T resY = fmod(m * (p.x - resX) - p.y , P);
        while(resX < 0)
            resX += P;
        while(resY < 0)
            resY += P;
        return Point<T>{resX, resY};
    };


    //NonSingular ECCs, have tangents defined for each points
    bool isNonSingularECC() const {
        return ((A < P && B < P) && (4*pow(A,3) + 27*pow(B,2) != 0));
    }

    /**
     * @brief   Function to evaluate the number of existing points
     *          on the elliptic curve using the Legendre Formula
     * @return  blabla
     */
    T numberOfPoints() const {
        T res = P + 1;
        for (uint64_t i = 0; i < P; ++i) {
            if (Mod::qMod(T(i), T(3), P) == T(1))
                res++;
        }
        return ++res; // +1 for the point at infinity
    }

    //TODO: Function double and add


    //Function to generate private key
    T generatePrivateKey() const {
        return rand() % P;
    }



    //TODO: Function to generate public key

    //TODO: Function to generate signature

    //TODO: Function to verify signature

    //TODO: Function to compress point

    //TODO: Function to decompress point

    //TODO: Function to generate key pair

    //TODO: Function to generate SEED

    //TODO: Function to generate Nothing Up My Sleeve Number

};

//EVA01_ELLIPTICCURVE_H
