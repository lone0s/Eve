//
// Created by jeune on 07/02/2023.
//

// y² = x^3 + ax + b

//Symétrie A(x,y) => B(x,-y)

#include <cmath>
#include <iostream>
#include "Point.h"
#include "Modulus.h"

/**
 *
 * TODO:
 *  2/ Point doubling: Given a point P on the curve, this method calculates
 *  the point 2P such that 2P is another point on the curve.
 *  This is done by finding the tangent to the curve at P and finding
 *  the second point where this tangent intersects the curve.
 *
 * TODO:
 *  3/Scalar multiplication: Given a point P on the curve and a scalar value k,
 *  this method calculates the point kP such that kP is another point on the curve.
 *  This is done by repeatedly adding P to itself k times,
 *  or by using faster algorithms such as double-and-add or Montgomery ladder.
 *
 * TODO:
 *  4/Point compression: Given a point P on the curve, this method compresses the point
 *  into a fixed-length representation for efficient storage and transmission.
 *  This is typically done by encoding the x-coordinate of the point
 *  and a flag indicating whether the y-coordinate is even or odd.
 *
 * TODO:
 *  5/Point decompression: Given a compressed point representation,
 *  this method decompresses the point back into its original form on the curve.
 *
 * TODO:
 *  6/Key generation: This method generates a public/private key pair for use in EllipticCurveEnc.
 *  The private key is a scalar value and the public key is a point on the curve.
 *  The public key is generated by multiplying the private key by the generator point of the curve.
 *
 * TODO:
 *  7/Signature generation: Given a message and a private key,
 *  this method generates a digital signature for the message.
 *  The signature is typically a pair of values that can be verified using the public key and the message.
 *
 * TODO:
 *  8/Signature verification: Given a signature, a message, and a public key,
 *  this method verifies whether the signature is a valid signature for the message.
 *  If the signature is valid, the method returns true, otherwise it returns false.
 */
//template <unsigned long long A, unsigned long long B>
class EllipticCurve {
    //y² === x^3 + Ax + B mod P
    // Field = P ; Fp = {0,1,...,p-1}
    // Need special point aka imaginary point == point soit sur +infini ou -infini
    public:
        long long A;
        long long B;
        long long P;

        EllipticCurve(long long modulo,
                      long long a,
                      long long b)
                      : A(a), B(b), P(modulo) {};

    //Point doubling ? <-- Use la tan d'un point puis symétrique par rapport a x pour récup

    //Chord Method || Point doubling si P == Q

    Point<long long> addition(Point<long long> &p, Point<long long> &Q) {
        long long m;
        if (p == Q) {
            m = Mod::qMod(p.y - Q.y,p.x - Q.x,this -> P );
        }
        else
            m = Mod::qMod(3*(p.x * p.x) + this->A, 2 * p.y, this -> P);
        std::cout << "m evaluated = " << m << std::endl;
        //Probleme du modulo sur des fractions, on doit remplacer par un inverse <-- Fixed
        // | m = (yP - yQ)(xP-xQ)^-1 mod p
        // | m = (3xP² + A)*(2yP)^-1 mod p
        long long resX = ((m*m) - p.x - Q.x) % this -> P;
        return Point<long long>{resX, (p.y + m * (resX - p.x)) % this -> P};
    };

    //NonSingular ECCs, have tangents defined for each points
    bool isNonSingularECC() const {
        return ((A < P && B < P) && (4*pow(A,3) + 27*pow(B,2) != 0));
    }
};

//EVA01_ELLIPTICCURVE_H
